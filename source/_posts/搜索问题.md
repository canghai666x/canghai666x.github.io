---
title: 搜索问题
date: 2018-09-12 20:00:43
tags: AI
---

# 搜索问题
    人类的思维过程，可以看作是一个搜索的过程。
一般而言，很多问题可以转化为状态空间的搜索问题。而问题的解，则是一个合法状态序列，其中序列的第一个状态是问题的*初始状态*。而最后的状态则是*结束状态*。之间的则是*中间状态*。除了第一个状态外，该序列中任何一个状态都可以通过一条*规则*由与他相临的前一个状态转化得到。

使用不同的搜索策略，找到解的搜索空间范围是有区别的。一般而言，对大空间问题，搜索策略是要解决组合爆炸的问题。

通常搜索策略的主要任务是确定如何选取规则的方式。有两种基本方式，一种是不考虑给定问题的特定知识，系统根据事先确定好的某种固定排序，依次调用规则或随机调用规则，这实际上是**盲目搜索**的方法，一般统称为**无信息引导的搜索策略**。
另一种是考虑问题领域可应用的知识，动态地确定规则的排序，优先调用合适的规则使用，这就是通常称为**启发式搜索策略**或**有信息引导的搜索策略**。
## 回溯策略
回溯策略属于盲目搜索的一种。
首先将规则给出一个固定的排序，在搜索时，对当前状态(初始状态)依次检测每一条规则，在当前状态未使用过的规则中找到第一条可用规则，应用于当前状态，得到的新状态重新设置为当前状态，并重复以上搜索。如果当前状态无规则所言，或者所有规则已经被试探过仍未找到问题的解，则当前状态的前一个状态(即直接生成该状态的状态)设置为当前状态。重复以上搜索，知道找到问题的解，或者试探了所有可能扔找不到问题的解为止。
### 递归过程BACKTRACK(DATA)
``` 
1. if team(data),return NIL; //team取true则找到目标，返回空表NIL。
2. if deadend(data) ,return FAIL;deadend取true,则状态不合法。
3. rules=apprules(datas); //计算可用规则集，按某种原则赋予rules.
4. loop: if NULL(rules), return FAIL; //NULL取真，则规则用完未找到目标。
5. R=first(rules);//取第一条可用规则。
6. rules=tail(rules); //删去第一条规则。
7. rdata=gen(r,data); //调用规则r作用于当前状态，生成新状态。
8. path=backtrack(rdata); //对新状态递归调用本过程。
9. if path == FAIL, go loop; //当path=fail，递归调用失败，规则转移进行下一组测试。
10. return cons(r,path); //返回解路径规则表。
```
### 递归过程BACKTRACK1(DATALIST)
上面的递归算法中设置了两个回溯点，一个是遇到非法状态，一个是试探了一个状态的所有子状态，仍找不到解时回溯。
对于某些问题会遇到这样的问题，某些问题某分支有无穷个状态，算法永远出不来，另一个问题是，遇到环路，搜索一直在环路中进行下去，都无法找到问题的解。

现为解决以上问题，给出递归算法1，增加两个回溯点：一个是用常量bound限制最大深度，避免落入深渊，无法回溯出来。另一个是讲过程的参数用初始状态到当前状态的表来代替当前状态，当新的状态产生时，查看是否已经在该表中出现过了，如果出现了，则表明有环路存在，进行回溯。
```
1. data=first(datalist); //设置data为当前状态。
2. if member(data,tail(datalist)),return FAIL; //取尾操作，表datalist中除了第一个以外所有元素，如果data在其中存在，则表示有环路，返回FAIL，回溯。
3. if term(data),return NIL; //term取真，找到目标，返回空表。
4. if deadend(data) ,return FAIL;deadend取true,则状态不合法。
5. if length(datalist)>bound,return FAIL; //计算搜索长度，大于bound，回溯。
6. rules=apprules(datas); //计算可用规则集，按某种原则赋予rules.
7. loop: if NULL(rules), return FAIL; //NULL取真，则规则用完未找到目标。
8. R=first(rules);//取第一条可用规则。
9.  rules=tail(rules); //删去第一条规则。
10. rdata=gen(r,data); //调用规则r作用于当前状态，生成新状态。
11. rdatalist=cons(rdata,datalist); //将新状态加入到表datalist中。
12. path=backtrack(rdatalist); //对新状态递归调用本过程。
13. if path == FAIL, go loop; //当path=fail，递归调用失败，规则转移进行下一组测试。
14.  return cons(r,path); //返回解路径规则表。
```
## 图搜索策略
回溯搜索策略只保留了从初始状态到当前状态的一条路径，当回溯出现时，回溯点处进行的搜索将被算法遗忘。其好处是节省了存储空间，而不足是这些被回溯掉的已经搜索过的部分，不能被以后使用。与之相对，讲所有搜索过的状态记录下来的搜索方法称为“图搜索”，搜索过的路径除了可以重复利用外，其最大的优点是可以更有效地利用与问题有关的一些知识，从而达到启发式搜索的目的。

图搜索策略是实现从一个隐含图中，生成出一部分确实含有一个目标节点的显式表示子图的搜索过程。

**一般图搜索算法**

* open表存放刚生成的节点
* closed表存放已访问的节点
```
1. g=g0(g0=s),open=(s); //g表示图，s为初始节点，设置open表，最初只含初始节点。
2. closed=()； //设置closed表为空表。
3. loop: if open==(),then exit(FAIL);
4. n=first(open),remove(n,open),add(n,closed);//n为当前节点。
5. if goal(n),then exit(success); //由n返回到s路径上的指针，可以给出解决路径。
6. expand(n)->{mi},g=add(mi,g); //子节点集{mi}中不包含n的父辈节点。
7. 标记和修改指针：
    * add(mj,open),并标记mj连接到n的指针;//mj为open和closed中未出现过的子节点;
    * 计算是否要修改mk,m1到n的指针; //mk为已出现在open中的子节点,m1为一出现在closed中的子节点,{mi}={mj}U{mk}U{m1};
    * 计算是狗要修改m1到其后继节点的指针。
8. 对open中的节点按照某种原则重新排序。
9 go loop.  
```