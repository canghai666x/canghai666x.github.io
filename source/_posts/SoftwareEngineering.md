---
title: 软件工程
date: 2018-11-20 
tags: Software Engineering
---
## 概述
### 软件危机
计算机发展早期，软件为个人编写使用。后来计算机迅速发展，软件数量急剧膨胀，需求与维护工作增加，资源耗费巨大，出现了软件危机。
软件危机是指软件在开发和维护过程中遇到的一系列严重问题。
软件危机含两方面问题：如何开发软件，以面对软件日益增长的需求；如何维护数量不断膨胀的已有软件。
#### 原因
- 软件维护通常意味着改正或修改原来的设计，客观使软件较难维护。
- 很多软件开发人员没有对软件开发和维护的观念，在实践中采用了错误的方法和技术。
- 计算机发展早期阶段的个人化特点，
- 没有对用户需求的完整认识。
    一个软件从定义、开发、使用、维护到废弃，软件经历的漫长时期叫生命周期。
#### 解决
为了解决软件危机，要有技术措施(方法和工具)，也要有必要的组织管理措施。
### 软件生命周期
概括地说，软件生命周期由软件定义，软件开发，软件维护三个时期组成。
1. 软件定义分为问题定义，可行性研究，需求分析。
2. 软件开发分为总体设计，详细设计，编码和单元测试，综合测试
3. 软件维护。
### 软件过程
软件过程是为了获得高质量软件的一系列任务的框架，规定了完成任务的工作步骤。
1. 瀑布模型
2. 快速原型模型
## 可行性研究
### 数据流图
描绘信息流和数据从输入移动到输出的过程所经受的变换。
数据流图没有任何具体物理部件，只描绘数据在软件中流动和被处理的逻辑过程。
#### 符号
正方形表示源点和终点，圆角矩形表示数据的处理，开口矩形代表数据存储，箭头表示数据流。
在数据流图中忽略出错处理和打开关闭文件的内务处理，基本要点是描述“做什么”，不考虑怎么做。
数据流图分为四忠诚纷纷，源点和终点，处理，数据存储，数据流。
## 需求分析
软件定义的最后一个时期，要求写出需求规格书。
### 实体-联系图
为了把用户的数据要求清楚准确的描述出来，通常寄哪里概念性的数据模型，ER图。
数据模型中包含了三种信息：数据对象，数据对象的属性，数据对象间的联系。
#### 符号
矩形框代表实体，椭圆或圆角矩形代表属性，直线连接。
### 状态转换图
在需求分析过程中应该建立起软件系统的行为模型。
状态转换图通过描绘系统的状态和引起系统状态转换的事件，来表示系统的行为。
状态图还指明了作为特定事件的结果系统将做哪些动作。
#### 状态
状态是任何可以被观察到的系统行为模式。
初态，终态，中间状态。
#### 事件
事件是在某个特定时刻发生的事情，引起系统从一个状态转换到另一个状态。
#### 符号
初态用实心圆，终态同心圆。
中间状态圆角矩形，上中下三部分，上面名称，中间状态变量的名和值，下面是活动表。
活动表：do/动作
## 总体设计
概括地说，系统应该怎么做。
可以站在全局角度熵，花费较少成本，选出最合理的软件结构，从而用低成本开发出较高质量的软件系统。
### 设计原理
- 模块化：把程序划分为独立的模块，使软件结构清晰，容易阅读和理解。
- 抽象。
- 逐步求精
#### 模块独立
模块独立的概念是模块化、抽象、信息隐藏、局部化概念的直接结果。+
##### 耦合
耦合是对一个软件结构内不同模块之间互相连接成都的度量。
追求低耦合，这样研究测试单独模块，不用对其他模块了解过多。
- 数据耦合：低耦合。仅仅通过参数交换数据。
- 控制耦合：中等耦合。
- 特征耦合：仅使用部分数据
- 内容耦合：高耦合，避免。
##### 内聚
内聚标志一个模块内各个元素彼此结合的紧密程度。
设计时应做到高内聚。
- 最高：功能内聚 10分
- 最低：偶然内聚 0分。
## 详细设计
设计出程序蓝图，程序员根据蓝图写出实际代码。
### 结构程序设计
三种控制结构：顺序，选择，循环
### 过程设计工具
描述城市处理过程的工具称为过程设计的工具。它们的基本要求是能够提供对设计的无歧义的描述，指明控制流程、处理功能、数据组织和其他方面的细节，从而在编码阶段能直接翻译成代码。
#### 流程图
1. 本质不是逐步求精的好工具，过早考虑程序控制流程不考虑整体。
2. 箭头代表数据流，不受约束。
3. 不易表示数据结构
#### 盒图
1. 功能域明确。
2. 不能任意转移控制。
3. 很容易确定局部和全局数据的作用域。
4. 很容易表示嵌套关系，层次结构。
#### PAD图
1. 逻辑易懂，自上而下，从左到右。
#### 判定表
判定表能够表示复杂的条件组合和应做的动作之间的对应关系。
## 实现
编码和测试统称实现。
### 编码
#### 编码风格
遵循规则
1. 内部文档
2. 数据说明
3. 语句构造
4. 输入输出
5. 效率
## 测试
### 单元测试
单元测试集中测试软件最小的单元——模块。
### 白盒测试
设计测试方案是测试阶段的关键技术问题。
把测试数据和预期输出结果称为测试用例。其中最困难的是设计测试的输入数据。
#### 逻辑覆盖
有选择地执行程序中某些最具代表性的通路是对穷尽测试的唯一可行的替代办法。
##### 语句覆盖
每个语句执行一次，语句覆盖是很弱的逻辑覆盖标准。
##### 判定覆盖
判定的每种可能结果至少执行一次。覆盖成度不高。
##### 条件覆盖
不仅每个语句至少执行一次，判定表达式中的每个条件都取到各种可能的结果。
可能不满足判定覆盖，不会把每条路径走一遍。
##### 条件组合覆盖
选取足够多的测试数据，使得每个判定表达式中条件的各种可能组合都至少出现一次。
### 黑盒测试
黑盒测试着重测试软件功能。与白盒测试互补。
#### 等价划分
把程序输入域划分为若干数据类，据此导出数据用例。
## 面向对象方法学引论
### 面向对象方法学
#### 要点
1. 对象
2. 类
3. 继承
4. 封装
#### 优点
1. 与人类习惯的思维方式一致
2. 稳定性好
3. 可重用性好
4. 开发大型软件容易
5. 可维护性好
### 对象模型
对象模型表示静态的，结构化的系统的数据性质。
通常，使用UML类图来建立对象模型。
#### 符号
1. 类的图形为长方形，上中下三层，名字，属性，服务。
2. 普通关联，只要类与类之间存在关系，就可以用普通关联来链接。
3. 聚集，是关联的特例。部分整体的关系
    - 共享聚集：在整体类边线端画空心菱形。
    - 组合聚集：实心菱形。
4. 泛化，继承。空心三角形，对着父类。
    抽象类:抽象操作后面有{abstract}
5. 依赖关系：虚线+实心三角
6. 细化：虚线+空心三角，抽象层次不同。
### 动态模型
    每个类的动态行为用一个状态图表示，各个类的状态图通过共享事件合起来，组成系统的动态模型。
### 功能模型
功能模型表示变化的系统的“功能”性质，它指明了系统应该“做什么”，因此更直接的反映了用户对系统的需求。
#### 用例图
一个用例图包含的模型元素有系统、行为者、用例及用例之间的关系。
1. 系统被看作一个提供用例的黑盒子。方框表示。
2. 一个用例是可以被行为者感受到的，系统的一个完整的功能。用例是一个类，不是具体实例。椭圆表示。
3. 行为者，与系统交互使用用例的人。
4. 用例之间的关系：
    - 扩展关系：向一个用例中添加一些动作称为另一个用例，后者称为扩展用例。
    - 使用关系：一个用例使用另一个用例，构成使用关系。在多个用例出现重复描述时，采用使用关系。
### 3种模型的关系
1. 针对每个类建立的动态模型，描述了类实例的生命周期或运行周期。
2. 状态转换驱使行为发生，这些行为在数据流图中映射为处理，在用例图中映射为用例，与类图中的服务队形。
3. 功能模型中的处理(用例)对应对象模型中类的服务。
## 面向对象分析
### 面向对象分析基本过程
- 从分析陈述用户需求的文件开始。
- 系统分析员应该深入理解用户需求
#### 三个子模型与五个层次
三个要素：
    静态结构(对象模型)、交互次序(动态模型)、数据变化(功能模型)
复杂系统容的对象模型通常由下述5个层次组成：
    主题层、类与对象层、结构层、属性层、服务层
主题是指导读者理解大型、复杂模型的一种范畴。通过划分主题把一个大型、复杂的对象模型分解成几个不同的范畴。
### 建立对象模型
面向对象分析首要的工作，是建立问题域的对象模型。
对象模型由5个层次，典型的工作步骤是：
    首先确认对象类和关联，对于大型复杂问题还要进一步划分出若干个主题，然后给类和关联增添属性，接下来利用继承关系进一步合并和组织类。
    而对类中操作的最后确定，则需等到建立了动态模型和功能模型之后，因为这两个字模型更准确地描述了对类中提供的服务的需求。
### 建立动态模型
#### 编写脚本
脚本描述用户与目标系统之间的一个或多个典型的交互过程，以确定对目标系统的行为由更具体的认识。
#### 画事件跟踪图
分析脚本，提取外部事件，画出事件跟踪图。
#### 画状态图。
状态图描绘事件与对象状态的关系。
### 建立功能模型
画数据流图
### 定义服务
- 常规行为
- 从事件导出的操作
- 与数据流图中处理框对应的操作
- 利用继承减少冗余
## 面向对象设计
### 准则
- 模块化
- 抽象
- 信息隐藏(封装)
- 弱耦合
- 强内聚
- 可重用