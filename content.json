{"meta":{"title":"CangHai's Blog","subtitle":"沧海的个人博客","description":"沧海的个人博客，记载我的学习经验","author":"CangHai","url":"http://canghai666x.github.io"},"pages":[{"title":"","date":"2020-09-23T03:33:43.570Z","updated":"2020-09-23T03:33:43.570Z","comments":true,"path":"404.html","permalink":"http://canghai666x.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2020-09-23T04:29:43.000Z","updated":"2020-09-23T04:30:05.078Z","comments":true,"path":"about/index.html","permalink":"http://canghai666x.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-09-23T04:27:05.000Z","updated":"2020-09-23T04:27:58.976Z","comments":true,"path":"categories/index.html","permalink":"http://canghai666x.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-09-23T03:29:45.000Z","updated":"2020-09-23T03:30:35.403Z","comments":true,"path":"tags/index.html","permalink":"http://canghai666x.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-09-23T02:42:06.728Z","updated":"2020-09-23T02:42:06.728Z","comments":true,"path":"2020/09/23/hello-world/","link":"","permalink":"http://canghai666x.github.io/2020/09/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"learnPostgres","slug":"learnPostgres","date":"2019-05-30T05:26:15.000Z","updated":"2020-09-23T02:42:06.728Z","comments":true,"path":"2019/05/30/learnPostgres/","link":"","permalink":"http://canghai666x.github.io/2019/05/30/learnPostgres/","excerpt":"","text":"学习使用PostgresSql数据库安装我使用的阿里云的服务器，系统是Centos7现在到Postgres的官网，选择相应的系统版本，获得相应的安装链接和命令。 首先添加rpm源 查看可以安装的postgresql版本 yum list | grep postgresql 安装 yum install postgresql11-contrib postgresql11-server -y 查看是否安装完成 rpm -aq| grep postgres安装完成后Postgresql安装目录是/usr/pgsql-11 文件目录是/var/lib/pgsql/11/data 初始化数据库 /usr/pgsql-11/bin/postgresql-11-setup initdb 设置自启动，并查看启动状态 systemctl enable postgresql-11systemctl start postgresql-11systemctl status postgresql-11 psql入门使用数据库安装后，会在自动创建一个Linux用户，名为postgres,自动创建一个Postgresql数据库的root用户，用户名就是postgres。这两个是不同的，前一个是Linux用户，后一个是PostgreSQL数据库的用户。现在切换到Linux用户-&gt;postgres中现在使用psql指令登录到PostgreSQL控制台中，在这里就可以进行数据库的操作啦，建立角色，授予权限，修改密码，创建数据库，表等等。好了，进入的第一件事，就是为了我们的root用户postgres设置一个密码，使用\\password user给用户修改密码 password postgres当本机Linux用户名和PostgresSQL用户名相同时，可以使用psql命令直接进入到数据库中。创建一个Linux用户，一个同名的PostgresSQL用户。创建Linux用户sudo adduser canghaisudo passwd canghai进入PostgresSQL用户，创建名为canghai的postgreSQL用户su - postgrespsqlcreate user canghai with password ‘**‘;创建一个测试数据库并授予全部权限给canghai这个用户create database test ower canghai;grant all privileges on database test to canghai;切换为Linux用户，并且登录到psql中psql可以直接登录同名数据库，没有同名数据库需要psql test进入test数据库中。也可以在任意用户下，通过用户名，密码，数据库，来登录。psql -U canghai -d test -h 127.0.0.1 -p 5432在这里遇到了一些错误，是因为默认情况下，PostgresSQL使用基于IDENT的身份验证，现在我们要修改配置文件，允许通过网络提供基于用户名和密码的身份验证。vim /var/lib/pgsql/11/data/pg_hba.conf修改配置文件，允许远程ip访问，在这里也可以调整端口重启postgresql-11systemctl restart postgresql-11在阿里云控制台中开启防火墙，允许5432端口通过检查防火墙是否开启&amp;是否允许通过firewall-cmd –permanent –add-port=5432/tcpsystemctl restart firewalld现在已经可以在控制台上通过账号密码登录也可以在本机上使用可视化工具通过网络连接数据库，我这里使用的是DataGrip","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://canghai666x.github.io/tags/SQL/"}]},{"title":"DES","slug":"DES","date":"2018-12-19T16:01:07.000Z","updated":"2020-09-23T02:42:06.727Z","comments":true,"path":"2018/12/20/DES/","link":"","permalink":"http://canghai666x.github.io/2018/12/20/DES/","excerpt":"","text":"DES原理简介DES加密算法，一种对称加密算法，加密速度比较快。DES算法有三个参数：Key（密钥）,Data（数据），Mode（加密/解密）。DES将64位明文加密位64位密文，当文本更长时划分位64位块进行每块一加密。DES加密和解密的流程是一样的，唯一不一样的地方在于密钥的顺序相反，如10100变成00101 流程图 加密过程获取子密钥KiDES初始密钥为64位，按8行8列从左往右上下排列，其中每行第八位用于奇偶校验(完整性)，不参与加密，实际参与加密运算的为56位。54位的实际Key经过密钥置换表PC-1置换之后，生成新的56位的串。这个密钥置换表貌似是固定的，因为解密加密是相同的操作，如果不固定怎么解密。经过PC-1置换后，将56位分为前28位C0和后28位D0两部分。然后分别循环左移1位得到C1和D1，然后合并成56位。然后经过PC-2压缩置换后生成48位的子密钥K1。C1、D1分别循环左移1位得到C2、D2，合并后经过PC-2压缩置换生成子密钥K2.同理，直至生成K16.每轮循环左移的位数也是固定的： 密码函数FIP置换64位数据经过IP表进行置换，生成后的新64位数据分为坐32位L0和右32位R0. E扩展置换将IP置换后的右半部分R0，扩展为48位输出。扩展置换表：将32位分为4位8列，两边取相邻的位进行扩展。 异或运算将扩展输出的48位和子密钥异或得到48位数据。 S盒置换将异或后的数据送入S盒，S盒置换由8个不同的S盒完成，每个S盒有6位输入4位输出。48位输入分为8个6位分组，输入到8个S盒中，在相应的S盒中置换。一个S盒就i是一个4行16列的表，盒中每一项都是一个4位的数(0000-1111即0-15)，S盒的6个输入确定了选择哪个项进行输出。输入的6位中，最高最低两位选择行数，中间四位选择列数，选择到的那个数字，就是S盒的输出值。（想不到吧，其他的都是用原文密钥通过某种函数来变换位置，这一步是通过数值确定坐标选择固定的表[S盒]中的值）例如S盒8的的输入是110011，第1位和第6位组合11，对应第三行，第二到第五位是1001，对应第9列，S盒8行9列的项是12，因此用12的二进制1100来代替输入110011输出。S盒置换过程输出8个4位的分组，组合在一起形成32位数据。S盒置换是DES算法的关键步骤，其他的运算都是线性的，容易分析，而S盒是非线性的，更安全。 P盒置换S盒的32位结果通过P盒再置换一次，生成新的32位输出结果。 迭代运算第一轮：R0与子密钥K1经过密码函数F(R0,K1)得到32位输出f1,f1与L0二进制异或赋值给R1，R0原封不动赋值给L1。第二轮：R1与子密钥K2经过密码函数F(R1,K2)得到32位输出f2，f2与L1二进制异或复制给R2，R1原封不动复制给L2.一共进行16轮，最后生成L16，R16. 末置换L16与R16合并在一起64位，经过末置换表IP-1置换，得到64位密文输出。","categories":[],"tags":[{"name":"encryption","slug":"encryption","permalink":"http://canghai666x.github.io/tags/encryption/"}]},{"title":"SSL协议配置及分析","slug":"SSL实验报告","date":"2018-12-08T16:00:00.000Z","updated":"2020-09-23T02:42:06.728Z","comments":true,"path":"2018/12/09/SSL实验报告/","link":"","permalink":"http://canghai666x.github.io/2018/12/09/SSL实验报告/","excerpt":"","text":"SSL协议配置及分析写一个网页和后台编写一个简单的网页，输入账号密码，并通过php打印出来。html代码:12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;SSLtest.css&quot;&gt; &lt;title&gt;SSLtest&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;SSLtest.php&quot; method=&quot;POST&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;p&gt;&lt;span&gt;用户名&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;userName&quot; required&gt;(必须填写)&lt;/p&gt; &lt;p&gt;&lt;span&gt;密码&lt;/span&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; required&gt;(必须填写)&lt;/p&gt; &lt;p&gt;&lt;span&gt;邮箱&lt;/span&gt;&lt;input type=&quot;email&quot; name=&quot;myemail&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;but&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; php代码:1234567891011&lt;?php$username=$_POST[&apos;userName&apos;];$password=$_POST[&apos;password&apos;];$myemail=$_POST[&apos;myemail&apos;];if(isset($username))&#123;echo &apos;用户名:&apos;.$username.&apos;&lt;br&gt;&apos;;&#125;if(isset($password))&#123;echo &apos;密码:&apos;.$password.&apos;&lt;br&gt;&apos;;&#125;if(isset($myemail))&#123;echo &apos;邮箱:&apos;.$myemail.&apos;&lt;br&gt;&apos;;&#125;?&gt; 通过服务器访问将代码放入服务器，并访问。我的是阿里云服务器，apache+php。访问效果如图:响应如图： 使用wireshark抓包通过ipconfig查询到本机ip:192.168.31.164服务器ip为:47.107.174.125配置wireshark过滤规则:服务器向本机发送的网页:可以看出是明文发送通过表单提交的账号信息：显然是明文传输，很容易就被抓包获取。 在服务器配置SSL 安装mod_ssl opensslyum install mod_ssl openssl 生成私钥 生成证书签名请求 生成自签名证书 创建文件夹，用来存放私钥和证书 将证书和私钥转移到ssl文件夹相应位置 更新Apache ssl配置文件路径为/etc/httpd/conf.d/ssl.conf 重启apache服务重启后ssl在全站起用配置ssl后测试 使用chrome登录测试网页浏览器显示不安全，因为是自签发的证书，没有经过CA机构签发，继续访问就是了。 输入数据进行发送测试 服务器响应 使用wireshark抓包可以看出发送数据的数据包协议为TLSv1.2,就是ssl。下面的数据内容是加密后的，无法看到明文。实验心得http使用明文传输数据，容易被拦截，造成信息泄露。https是在http基础上使用了TLS(SSL)进行加密传输，SSL可使用RSA非对称算法进行加密，这样只有通信的两端可以解析数据。公共的网站可以自己生成一个私钥(key)，然后通过私钥生成一个证书签名请求(csr)，一般来说将证书签名请求发给CA机构(公共的证书签发机构)进行申请证书，也可以自己通过工具生成自签名证书。证书签发： 首先撰写证书的元信息：签发人，域名，时间，有效期等，还要附加签发人的公钥。 通过Hash算法将信息摘要提取。 Hash提取的摘要通过CA的私钥进行加密，生成密文。 将密文附在签发信息上，成为一个CA签名过的证书。验证证书： 浏览器获得证书 解压后得到元数据和签名密文 用Hash算法将元数据提取摘要 通过CA机构的公钥解密获得加密的摘要值 如果两个摘要匹配，则说明这个证书是被CA验证过签发的合法证书，里面的公钥等信息是可信的 自签名证书不被浏览器所信任，因为自签名证书由于可被假冒伪造等原因不安全。 操作系统中有受信任的根证书库其中存放操作系统帮我们下载好的一些国际上可信的知名的证书颁发机构CA的根证书。(如果证书机构完蛋了，操作系统也会把它的根证书删除)CA机构一般通过签发多个二级证书，再用二级证书给申请证书的人/公司签发证书。被签发的证书中会含有它的签发上级的证书信息，由此可以得到一个证书链，如果我们信任了它的根证书，通过根证书的公钥解密二级证书(hash)，验证二级证书的完整性，成功则可信，如此一级级验证下去，最终确认所访问网站是可信的。 用户可以手动信任(测试用)网站。通过TLS加密后，在中间嗅探无法直接看到明文的账号密码，安全很多啊","categories":[],"tags":[{"name":"TLS","slug":"TLS","permalink":"http://canghai666x.github.io/tags/TLS/"}]},{"title":"关于java中判断相等的一些思考","slug":"java判断相等","date":"2018-11-25T16:00:00.000Z","updated":"2020-09-23T02:42:06.728Z","comments":true,"path":"2018/11/26/java判断相等/","link":"","permalink":"http://canghai666x.github.io/2018/11/26/java判断相等/","excerpt":"","text":"关于java中判断相等的一些思考前两天，一个网友在群里问了一个问题，关于java的String判断相等。举个简单的例子输出结果是falsefalse而使用equals方法来判断结果就是truetrue由此，我们知道，在java中想判断两个字符串的内容是否相同，应该使用String对象的equals方法。但是在这里我们只是知道了How，却不知道Why。我对此有了好奇心，为什么java的String这么特殊，明明都是“aaa”，用==来判断就是false，用equals来判断就ture呢？ 第一个问题，为啥==不可以判断String是否相等想搞明白这个问题，首先就要去找==的实现。==是基础运算符，在jdk中并没有，是由虚拟机实现的。我看了一下The Java® Virtual Machine Specification Java SE 10 Edition，也就是java虚拟机规范。2.2 Data Types中说 he Java Virtual Machine operates on two kinds of types: primitive types and reference types java虚拟机有两种类型，基础数据类型和引用类型。基础数据类型有8中：byte,short,int,long,char,float,double,boolean.2.4 Reference Types and Values中说 here are three kinds of reference types: class types, array types, and interface types. Their values are references to dynamically created class instances, arrays, or class instances or arrays that implement interfaces, respectively. 引用类型有三种，类类型、数组类型、接口类型，他们的值分别是对类和数组的实例或实现的接口的数组的引用。2.7 Representation of Objects中说 The Java Virtual Machine does not mandate any particular internal structure for objects.In some of Oracle’s implementations of the Java Virtual Machine, a reference to a class instance is a pointer to a handle that is itself a pair of pointers: one to a table containing the methods of the object and a pointer to the Class object that represents the type of the object, and the other to the memory allocated from the heap for the object data. 对象的表示：在oracle虚拟机中，对类实例的引用是指向句柄的指针。现在，我们知道，上面我们创建了两个对象值为“aaa”的字符串，分别交给引用astring和bstring.这两个引用，也就是指针，指向了不同的实例，两个实例存在于堆中。显然两个实例所在的位置不同，地址不同，引用值也不同。在Table 2.11.1-A中有java虚拟机支持的指令集在2.11.3中解释了算术指令 Comparison: dcmpg, dcmpl, fcmpg, fcmpl, lcmp. 比较指令有这些，对比指令集可以看出，reference类型并不支持比较，所以在实际中会将引用类型的值转换为支持比较指令lcmp的long类型比较。 综上所述，==比较两个对象引用比较的是两个对象在堆中的地址，而不是对象的value，而地址不同，指针值转化为long值比较的结果就是false了。 第二个问题，为啥equals方法可以比较两个String对象的值呢？查找到String的源码中的equals方法：如果两个对象是同一个，也就是说引用值相同，直接返回true.不然判断这个对象是否是String的实例，是的话讲目标对象强转为String类型，比较。先判断编码格式，如果是Latin1编码，使用StringLatin1的equals方法比较两个字符串的value,如果是utf16编码,使用StringUTF16的equals比较两个字符串对象的value。value是String对象的一个属性，byte[]类型。String的编码类型：如果String存的全是英文，就用Latin1；如果有中文，就用utf16.我们先看StringLatin1.equals()的实现。逐个比较byte[]的每一位，而byte是基础类型，实际上也是添0转long比较，是可以直接比较的。好了，如此将两个String的value属性(byte[]类型)按位比较，是可以正确比较的。 至于StringUTF16.euqals()的实现，感兴趣的朋友自己去看看吧。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://canghai666x.github.io/tags/java/"}]},{"title":"软件工程","slug":"SoftwareEngineering","date":"2018-11-19T16:00:00.000Z","updated":"2020-09-23T02:42:06.728Z","comments":true,"path":"2018/11/20/SoftwareEngineering/","link":"","permalink":"http://canghai666x.github.io/2018/11/20/SoftwareEngineering/","excerpt":"","text":"概述软件危机计算机发展早期，软件为个人编写使用。后来计算机迅速发展，软件数量急剧膨胀，需求与维护工作增加，资源耗费巨大，出现了软件危机。软件危机是指软件在开发和维护过程中遇到的一系列严重问题。软件危机含两方面问题：如何开发软件，以面对软件日益增长的需求；如何维护数量不断膨胀的已有软件。 原因 软件维护通常意味着改正或修改原来的设计，客观使软件较难维护。 很多软件开发人员没有对软件开发和维护的观念，在实践中采用了错误的方法和技术。 计算机发展早期阶段的个人化特点， 没有对用户需求的完整认识。 一个软件从定义、开发、使用、维护到废弃，软件经历的漫长时期叫生命周期。解决为了解决软件危机，要有技术措施(方法和工具)，也要有必要的组织管理措施。软件生命周期概括地说，软件生命周期由软件定义，软件开发，软件维护三个时期组成。 软件定义分为问题定义，可行性研究，需求分析。 软件开发分为总体设计，详细设计，编码和单元测试，综合测试 软件维护。软件过程软件过程是为了获得高质量软件的一系列任务的框架，规定了完成任务的工作步骤。 瀑布模型 快速原型模型可行性研究数据流图描绘信息流和数据从输入移动到输出的过程所经受的变换。数据流图没有任何具体物理部件，只描绘数据在软件中流动和被处理的逻辑过程。符号正方形表示源点和终点，圆角矩形表示数据的处理，开口矩形代表数据存储，箭头表示数据流。在数据流图中忽略出错处理和打开关闭文件的内务处理，基本要点是描述“做什么”，不考虑怎么做。数据流图分为四忠诚纷纷，源点和终点，处理，数据存储，数据流。需求分析软件定义的最后一个时期，要求写出需求规格书。实体-联系图为了把用户的数据要求清楚准确的描述出来，通常寄哪里概念性的数据模型，ER图。数据模型中包含了三种信息：数据对象，数据对象的属性，数据对象间的联系。符号矩形框代表实体，椭圆或圆角矩形代表属性，直线连接。状态转换图在需求分析过程中应该建立起软件系统的行为模型。状态转换图通过描绘系统的状态和引起系统状态转换的事件，来表示系统的行为。状态图还指明了作为特定事件的结果系统将做哪些动作。状态状态是任何可以被观察到的系统行为模式。初态，终态，中间状态。事件事件是在某个特定时刻发生的事情，引起系统从一个状态转换到另一个状态。符号初态用实心圆，终态同心圆。中间状态圆角矩形，上中下三部分，上面名称，中间状态变量的名和值，下面是活动表。活动表：do/动作总体设计概括地说，系统应该怎么做。可以站在全局角度熵，花费较少成本，选出最合理的软件结构，从而用低成本开发出较高质量的软件系统。设计原理 模块化：把程序划分为独立的模块，使软件结构清晰，容易阅读和理解。 抽象。 逐步求精模块独立模块独立的概念是模块化、抽象、信息隐藏、局部化概念的直接结果。+耦合耦合是对一个软件结构内不同模块之间互相连接成都的度量。追求低耦合，这样研究测试单独模块，不用对其他模块了解过多。 数据耦合：低耦合。仅仅通过参数交换数据。 控制耦合：中等耦合。 特征耦合：仅使用部分数据 内容耦合：高耦合，避免。内聚内聚标志一个模块内各个元素彼此结合的紧密程度。设计时应做到高内聚。 最高：功能内聚 10分 最低：偶然内聚 0分。详细设计设计出程序蓝图，程序员根据蓝图写出实际代码。结构程序设计三种控制结构：顺序，选择，循环过程设计工具描述城市处理过程的工具称为过程设计的工具。它们的基本要求是能够提供对设计的无歧义的描述，指明控制流程、处理功能、数据组织和其他方面的细节，从而在编码阶段能直接翻译成代码。流程图 本质不是逐步求精的好工具，过早考虑程序控制流程不考虑整体。 箭头代表数据流，不受约束。 不易表示数据结构盒图 功能域明确。 不能任意转移控制。 很容易确定局部和全局数据的作用域。 很容易表示嵌套关系，层次结构。PAD图 逻辑易懂，自上而下，从左到右。判定表判定表能够表示复杂的条件组合和应做的动作之间的对应关系。实现编码和测试统称实现。编码编码风格遵循规则 内部文档 数据说明 语句构造 输入输出 效率测试单元测试单元测试集中测试软件最小的单元——模块。白盒测试设计测试方案是测试阶段的关键技术问题。把测试数据和预期输出结果称为测试用例。其中最困难的是设计测试的输入数据。逻辑覆盖有选择地执行程序中某些最具代表性的通路是对穷尽测试的唯一可行的替代办法。语句覆盖每个语句执行一次，语句覆盖是很弱的逻辑覆盖标准。判定覆盖判定的每种可能结果至少执行一次。覆盖成度不高。条件覆盖不仅每个语句至少执行一次，判定表达式中的每个条件都取到各种可能的结果。可能不满足判定覆盖，不会把每条路径走一遍。条件组合覆盖选取足够多的测试数据，使得每个判定表达式中条件的各种可能组合都至少出现一次。黑盒测试黑盒测试着重测试软件功能。与白盒测试互补。等价划分把程序输入域划分为若干数据类，据此导出数据用例。面向对象方法学引论面向对象方法学要点 对象 类 继承 封装优点 与人类习惯的思维方式一致 稳定性好 可重用性好 开发大型软件容易 可维护性好对象模型对象模型表示静态的，结构化的系统的数据性质。通常，使用UML类图来建立对象模型。符号 类的图形为长方形，上中下三层，名字，属性，服务。 普通关联，只要类与类之间存在关系，就可以用普通关联来链接。 聚集，是关联的特例。部分整体的关系 共享聚集：在整体类边线端画空心菱形。 组合聚集：实心菱形。 泛化，继承。空心三角形，对着父类。 抽象类:抽象操作后面有{abstract} 依赖关系：虚线+实心三角 细化：虚线+空心三角，抽象层次不同。动态模型 每个类的动态行为用一个状态图表示，各个类的状态图通过共享事件合起来，组成系统的动态模型。功能模型功能模型表示变化的系统的“功能”性质，它指明了系统应该“做什么”，因此更直接的反映了用户对系统的需求。用例图一个用例图包含的模型元素有系统、行为者、用例及用例之间的关系。 系统被看作一个提供用例的黑盒子。方框表示。 一个用例是可以被行为者感受到的，系统的一个完整的功能。用例是一个类，不是具体实例。椭圆表示。 行为者，与系统交互使用用例的人。 用例之间的关系： 扩展关系：向一个用例中添加一些动作称为另一个用例，后者称为扩展用例。 使用关系：一个用例使用另一个用例，构成使用关系。在多个用例出现重复描述时，采用使用关系。3种模型的关系 针对每个类建立的动态模型，描述了类实例的生命周期或运行周期。 状态转换驱使行为发生，这些行为在数据流图中映射为处理，在用例图中映射为用例，与类图中的服务队形。 功能模型中的处理(用例)对应对象模型中类的服务。面向对象分析面向对象分析基本过程 从分析陈述用户需求的文件开始。 系统分析员应该深入理解用户需求三个子模型与五个层次三个要素： 静态结构(对象模型)、交互次序(动态模型)、数据变化(功能模型)复杂系统容的对象模型通常由下述5个层次组成： 主题层、类与对象层、结构层、属性层、服务层主题是指导读者理解大型、复杂模型的一种范畴。通过划分主题把一个大型、复杂的对象模型分解成几个不同的范畴。建立对象模型面向对象分析首要的工作，是建立问题域的对象模型。对象模型由5个层次，典型的工作步骤是： 首先确认对象类和关联，对于大型复杂问题还要进一步划分出若干个主题，然后给类和关联增添属性，接下来利用继承关系进一步合并和组织类。 而对类中操作的最后确定，则需等到建立了动态模型和功能模型之后，因为这两个字模型更准确地描述了对类中提供的服务的需求。建立动态模型编写脚本脚本描述用户与目标系统之间的一个或多个典型的交互过程，以确定对目标系统的行为由更具体的认识。画事件跟踪图分析脚本，提取外部事件，画出事件跟踪图。画状态图。状态图描绘事件与对象状态的关系。建立功能模型画数据流图定义服务 常规行为 从事件导出的操作 与数据流图中处理框对应的操作 利用继承减少冗余面向对象设计准则 模块化 抽象 信息隐藏(封装) 弱耦合 强内聚 可重用","categories":[],"tags":[{"name":"Software Engineering","slug":"Software-Engineering","permalink":"http://canghai666x.github.io/tags/Software-Engineering/"}]},{"title":"learnMVC","slug":"learnMVC","date":"2018-09-19T11:10:54.000Z","updated":"2020-09-23T02:42:06.728Z","comments":true,"path":"2018/09/19/learnMVC/","link":"","permalink":"http://canghai666x.github.io/2018/09/19/learnMVC/","excerpt":"","text":"Learn MVCmodel1C/S:客户端/服务端 B/S：浏览器/服务器 jsp+javaBean javaBen是普通的java类，具有属性，默认构造器，和属性的setter/getter方法 model2MVC开发模式JSP+Servlet+javaBean. M:Model模型，javaBean,封装数据 V:View视图 ，JSP C:Controller控制器，servlet 理解：浏览器请求数据，请求交给C,servlet处理转发，从数据库中提取数据封装到模型model中，将模型交给jsp形成视图html页面，把jsp页面返回给浏览器。 分层思想在开发中，应用分层思想进行更细致的划分。Servlet有三个功能，获取表单数据，处理业务逻辑，分发转向，将业务逻辑剥离出来，作为业务层Service，专门处理业务逻辑。再将处理数据即增删改查剥离出作为数据访问层Dao。","categories":[],"tags":[{"name":"javaweb MVC","slug":"javaweb-MVC","permalink":"http://canghai666x.github.io/tags/javaweb-MVC/"}]},{"title":"搜索问题","slug":"搜索问题","date":"2018-09-12T12:00:43.000Z","updated":"2020-09-23T02:42:06.729Z","comments":true,"path":"2018/09/12/搜索问题/","link":"","permalink":"http://canghai666x.github.io/2018/09/12/搜索问题/","excerpt":"","text":"搜索问题人类的思维过程，可以看作是一个搜索的过程。 一般而言，很多问题可以转化为状态空间的搜索问题。而问题的解，则是一个合法状态序列，其中序列的第一个状态是问题的初始状态。而最后的状态则是结束状态。之间的则是中间状态。除了第一个状态外，该序列中任何一个状态都可以通过一条规则由与他相临的前一个状态转化得到。 使用不同的搜索策略，找到解的搜索空间范围是有区别的。一般而言，对大空间问题，搜索策略是要解决组合爆炸的问题。 通常搜索策略的主要任务是确定如何选取规则的方式。有两种基本方式，一种是不考虑给定问题的特定知识，系统根据事先确定好的某种固定排序，依次调用规则或随机调用规则，这实际上是盲目搜索的方法，一般统称为无信息引导的搜索策略。另一种是考虑问题领域可应用的知识，动态地确定规则的排序，优先调用合适的规则使用，这就是通常称为启发式搜索策略或有信息引导的搜索策略。 回溯策略回溯策略属于盲目搜索的一种。首先将规则给出一个固定的排序，在搜索时，对当前状态(初始状态)依次检测每一条规则，在当前状态未使用过的规则中找到第一条可用规则，应用于当前状态，得到的新状态重新设置为当前状态，并重复以上搜索。如果当前状态无规则所言，或者所有规则已经被试探过仍未找到问题的解，则当前状态的前一个状态(即直接生成该状态的状态)设置为当前状态。重复以上搜索，知道找到问题的解，或者试探了所有可能扔找不到问题的解为止。 递归过程BACKTRACK(DATA)123456789101. if team(data),return NIL; //team取true则找到目标，返回空表NIL。2. if deadend(data) ,return FAIL;deadend取true,则状态不合法。3. rules=apprules(datas); //计算可用规则集，按某种原则赋予rules.4. loop: if NULL(rules), return FAIL; //NULL取真，则规则用完未找到目标。5. R=first(rules);//取第一条可用规则。6. rules=tail(rules); //删去第一条规则。7. rdata=gen(r,data); //调用规则r作用于当前状态，生成新状态。8. path=backtrack(rdata); //对新状态递归调用本过程。9. if path == FAIL, go loop; //当path=fail，递归调用失败，规则转移进行下一组测试。10. return cons(r,path); //返回解路径规则表。 递归过程BACKTRACK1(DATALIST)上面的递归算法中设置了两个回溯点，一个是遇到非法状态，一个是试探了一个状态的所有子状态，仍找不到解时回溯。对于某些问题会遇到这样的问题，某些问题某分支有无穷个状态，算法永远出不来，另一个问题是，遇到环路，搜索一直在环路中进行下去，都无法找到问题的解。 现为解决以上问题，给出递归算法1，增加两个回溯点：一个是用常量bound限制最大深度，避免落入深渊，无法回溯出来。另一个是讲过程的参数用初始状态到当前状态的表来代替当前状态，当新的状态产生时，查看是否已经在该表中出现过了，如果出现了，则表明有环路存在，进行回溯。12345678910111213141. data=first(datalist); //设置data为当前状态。2. if member(data,tail(datalist)),return FAIL; //取尾操作，表datalist中除了第一个以外所有元素，如果data在其中存在，则表示有环路，返回FAIL，回溯。3. if term(data),return NIL; //term取真，找到目标，返回空表。4. if deadend(data) ,return FAIL;deadend取true,则状态不合法。5. if length(datalist)&gt;bound,return FAIL; //计算搜索长度，大于bound，回溯。6. rules=apprules(datas); //计算可用规则集，按某种原则赋予rules.7. loop: if NULL(rules), return FAIL; //NULL取真，则规则用完未找到目标。8. R=first(rules);//取第一条可用规则。9. rules=tail(rules); //删去第一条规则。10. rdata=gen(r,data); //调用规则r作用于当前状态，生成新状态。11. rdatalist=cons(rdata,datalist); //将新状态加入到表datalist中。12. path=backtrack(rdatalist); //对新状态递归调用本过程。13. if path == FAIL, go loop; //当path=fail，递归调用失败，规则转移进行下一组测试。14. return cons(r,path); //返回解路径规则表。 图搜索策略回溯搜索策略只保留了从初始状态到当前状态的一条路径，当回溯出现时，回溯点处进行的搜索将被算法遗忘。其好处是节省了存储空间，而不足是这些被回溯掉的已经搜索过的部分，不能被以后使用。与之相对，讲所有搜索过的状态记录下来的搜索方法称为“图搜索”，搜索过的路径除了可以重复利用外，其最大的优点是可以更有效地利用与问题有关的一些知识，从而达到启发式搜索的目的。 图搜索策略是实现从一个隐含图中，生成出一部分确实含有一个目标节点的显式表示子图的搜索过程。 一般图搜索算法 open表存放刚生成的节点 closed表存放已访问的节点1234567891011121. g=g0(g0=s),open=(s); //g表示图，s为初始节点，设置open表，最初只含初始节点。2. closed=()； //设置closed表为空表。3. loop: if open==(),then exit(FAIL);4. n=first(open),remove(n,open),add(n,closed);//n为当前节点。5. if goal(n),then exit(success); //由n返回到s路径上的指针，可以给出解决路径。6. expand(n)-&gt;&#123;mi&#125;,g=add(mi,g); //子节点集&#123;mi&#125;中不包含n的父辈节点。7. 标记和修改指针： * add(mj,open),并标记mj连接到n的指针;//mj为open和closed中未出现过的子节点; * 计算是否要修改mk,m1到n的指针; //mk为已出现在open中的子节点,m1为一出现在closed中的子节点,&#123;mi&#125;=&#123;mj&#125;U&#123;mk&#125;U&#123;m1&#125;; * 计算是狗要修改m1到其后继节点的指针。8. 对open中的节点按照某种原则重新排序。9 go loop.","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"http://canghai666x.github.io/tags/AI/"}]},{"title":"操作系统笔记","slug":"OS1","date":"2018-09-10T12:25:36.000Z","updated":"2020-09-23T02:42:06.727Z","comments":true,"path":"2018/09/10/OS1/","link":"","permalink":"http://canghai666x.github.io/2018/09/10/OS1/","excerpt":"","text":"操作系统引论操作系统的作用和目标操作系统的目标 方便性：没有操作系统的计算机是很难使用的，通过操作系统提供的命令操作计算机系统，方便用户。 有效性：提高设备资源利用率，提高系统吞吐量。 可扩充性：从早期的无结构化发展成模块化，层次化，近年来采用微内核化，方便增加新的功能和模块。 开放性：解决计算机系统的硬件软件的兼容问题。操作系统的作用 作为用户与计算机硬件系统间的接口，用户通过操作系统来使用计算机系统。 作为计算机系统资源的管理者，处理机管理，存储器管理，IO设备管理，文件管理。 实现了对计算机资源的抽象，IO抽象隐藏硬件，文件抽象覆盖IO，窗口软件覆盖文件操作，OS是铺设在计算机硬件上的多层软件的集合，他们不仅增强了系统的功能，还隐藏了对操作系统的具体细节。推动操作系统发展的动力 提高计算机资源利用率 方便用户 器件的更新换代 计算机体系结构的不断发展，例如从单处理机发展为多处理机时。 不断提出新的应用需求，音乐媒体等。操作系统的发展过程未配置操作系统的计算机系统 人工操作方式 脱机输入输出单批道处理系统 处理过程：把一批作业以脱机方式输入到磁带，配置监督程序，顺序执行。 缺点：资源得不到充分利用，CPU利用率低。多批道处理系统 IBM360 OS/360 概念：作业先存放在外存，形成后备队列，按一定算法，选出若干个调入内存，共享CPU和系统资源。A进行IO时，B进行CPU运算，交替进行。 优缺点：优-资源利用率高，吞吐量大；缺-平均周转期长，依次排队处理，耗时久，无交互能力，从开始到完成，用户不能交互。 需要解决的问题： 1)处理机争用问题，2)内存分配和保护问题，3)IO设备管理问题，4)文件组织和管理问题，5)作业管理问题，6)用户与系统的接口问题。 操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用程序的集合 分时系统 引入：解决人机交互问题，希望独占式共享主机。 关键问题：1)及时接收，配置多路卡，及时接收多个用户键入的命令和数据。分时多路复用，很快地扫描各个终端接收数据。2）及时处理，1作业直接进入内存，2采用轮转运行方式。 特征：多路性、独立性、及时性、交互性。实时系统 常见类型：工业（武器）控制系统，信息查询系统，多媒体系统，嵌入式系统。 实时任务类型： (1) 周期性任务，非周期性任务：开始截止时间和完成截止时间，有时间要求。 （2）硬时性任务和软时性任务、微机操作系统的发展 单用户单任务 单用户多任务 多用户多任务基本特征并发 并行和并发：并行指多个事件同一时刻发生，并发指多个事件在很短时间内发生。 引入进程：指在系统中能独立运行并作为系统分配资源的基本单位，它是由一组机器指令、数据和堆栈组成，是一个独立运行的活动实体。多个进程间可并发执行和交换信息。共享 互斥共享方式，如打印机。 同时访问方式，如磁盘。虚拟","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"http://canghai666x.github.io/tags/OS/"}]},{"title":"servlet学习笔记","slug":"servlet学习笔记","date":"2018-09-08T06:04:46.000Z","updated":"2020-09-23T02:42:06.728Z","comments":true,"path":"2018/09/08/servlet学习笔记/","link":"","permalink":"http://canghai666x.github.io/2018/09/08/servlet学习笔记/","excerpt":"","text":"time: 2018/9/6servlet是什么?tomcat是web应用服务器，是一个servlet/jsp容器，负责处理客户请求，把http请求传给servlet，并将servlet的响应传回给客户。 java servlet是运行在web服务器上(例如 tomcat )的小型应用程序，它作为浏览器和服务器的中转站，接收网页表单的数据，响应浏览器的请求。 为什么要有servlet?当向web服务器请求一个资源时，web服务器擅长提供静态页面(web服务器不能提供动态即使页面,不能向数据库存程序)，如果需要一个动态的内容，则需要一种辅助程序，web服务器会调用辅助程序来完成动态页面的展示。 例如说在一个网页输入账号密码，然后登陆跳转，这个时候页面就会跳转(跳转方法有get/post)，在web.xml中配置servlet路径，跳转到servlet去，讲请求交给servlet处理。servlet就是接受页面信息然后进行逻辑处理的一个java类。 Servlet的生命周期Servlet的生命周期即Servlet从出生到死亡，经历了加载，初始化，服务，销毁四个阶段。这些都是由web容器(tomcat)控制的，而初始化，服务，销毁时我们程序员可以自己去添加内容的，然后由web容器调用。 Servlet有几个方法，实现了初始化，服务，销毁的功能。 init()方法，初始化，仅第一次创建这个Servlet时调用。 service()方法，执行实际任务的主要方法，每当服务器接收到Servlet请求，服务器产生一个新的线程并调用服务，Service()根据Http请求在适当的时候调用doGet,doPost,doPut,dodelete等方法。 doGet()方法，接收正常的URL请求，或未指定method的HTML表单。 doPost()方法，接收method为POST的HTML表单。 destory()方法，destory方法只会调用一次，生命周期结束时调用，什么时候结束由web容器决定，或者关闭服务器时自然结束。生命周期示例启动服务器，访问页面后，看控制台信息。点击页面 控制台信息，可以看出先后进行了执行了init(),service(),doPost(). 即如下顺序再一起发起提交，并没有第二次初始化，初始化仅进行一次。 其中，service()方法由我们重写了，所以要在service中调用一下父类，否则不会调用doPost等，因为自动分配调用是由tomcat自带的service中的代码实现的。","categories":[],"tags":[{"name":"servlet javaweb","slug":"servlet-javaweb","permalink":"http://canghai666x.github.io/tags/servlet-javaweb/"}]}]}